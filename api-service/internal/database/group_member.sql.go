// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: group_member.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countMemmbersInGroup = `-- name: CountMemmbersInGroup :one
SELECT
	count(member_id)
FROM
	group_members
WHERE
	group_id = $1
`

func (q *Queries) CountMemmbersInGroup(ctx context.Context, groupID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countMemmbersInGroup, groupID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createGroupMember = `-- name: CreateGroupMember :one
INSERT INTO
	group_members ("group_id", "member_id", "joined_at")
VALUES
	($1, $2, $3)
RETURNING
	group_id, member_id, joined_at
`

type CreateGroupMemberParams struct {
	GroupID  pgtype.UUID      `json:"group_id"`
	MemberID pgtype.UUID      `json:"member_id"`
	JoinedAt pgtype.Timestamp `json:"joined_at"`
}

func (q *Queries) CreateGroupMember(ctx context.Context, arg CreateGroupMemberParams) (GroupMember, error) {
	row := q.db.QueryRow(ctx, createGroupMember, arg.GroupID, arg.MemberID, arg.JoinedAt)
	var i GroupMember
	err := row.Scan(&i.GroupID, &i.MemberID, &i.JoinedAt)
	return i, err
}

const deleteGroupMemmber = `-- name: DeleteGroupMemmber :exec
DELETE FROM group_members
WHERE
	group_id = $1
	AND member_id = $2
`

type DeleteGroupMemmberParams struct {
	GroupID  pgtype.UUID `json:"group_id"`
	MemberID pgtype.UUID `json:"member_id"`
}

func (q *Queries) DeleteGroupMemmber(ctx context.Context, arg DeleteGroupMemmberParams) error {
	_, err := q.db.Exec(ctx, deleteGroupMemmber, arg.GroupID, arg.MemberID)
	return err
}

const findGroupMember = `-- name: FindGroupMember :one
SELECT
	group_id, member_id, joined_at
FROM
	group_members
WHERE
	group_id = $1
	AND member_id = $2
`

type FindGroupMemberParams struct {
	GroupID  pgtype.UUID `json:"group_id"`
	MemberID pgtype.UUID `json:"member_id"`
}

func (q *Queries) FindGroupMember(ctx context.Context, arg FindGroupMemberParams) (GroupMember, error) {
	row := q.db.QueryRow(ctx, findGroupMember, arg.GroupID, arg.MemberID)
	var i GroupMember
	err := row.Scan(&i.GroupID, &i.MemberID, &i.JoinedAt)
	return i, err
}

const getAllGroupMemberInfo = `-- name: GetAllGroupMemberInfo :many
SELECT
	u.user_id,
	u.user_name,
	u.profile_image,
	g.joined_at
FROM
	(
		SELECT
			group_id, member_id, joined_at
		FROM
			group_members
		WHERE
			group_id = $1
	) g
	LEFT JOIN users u ON g.member_id = u.user_id
ORDER BY
	g.joined_at
LIMIT
	$2
OFFSET
	$3
`

type GetAllGroupMemberInfoParams struct {
	GroupID pgtype.UUID `json:"group_id"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type GetAllGroupMemberInfoRow struct {
	UserID       pgtype.UUID      `json:"user_id"`
	UserName     pgtype.Text      `json:"user_name"`
	ProfileImage pgtype.Text      `json:"profile_image"`
	JoinedAt     pgtype.Timestamp `json:"joined_at"`
}

func (q *Queries) GetAllGroupMemberInfo(ctx context.Context, arg GetAllGroupMemberInfoParams) ([]GetAllGroupMemberInfoRow, error) {
	rows, err := q.db.Query(ctx, getAllGroupMemberInfo, arg.GroupID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllGroupMemberInfoRow{}
	for rows.Next() {
		var i GetAllGroupMemberInfoRow
		if err := rows.Scan(
			&i.UserID,
			&i.UserName,
			&i.ProfileImage,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserGroupIds = `-- name: GetAllUserGroupIds :many
SELECT
	group_id
FROM
	group_members
WHERE
	member_id = $1
`

func (q *Queries) GetAllUserGroupIds(ctx context.Context, memberID pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getAllUserGroupIds, memberID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.UUID{}
	for rows.Next() {
		var group_id pgtype.UUID
		if err := rows.Scan(&group_id); err != nil {
			return nil, err
		}
		items = append(items, group_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserGroups = `-- name: GetAllUserGroups :many
SELECT
	g.group_id, g.group_name, g.group_picture, g.created_by, g.created_at,
	cm.joined_at
FROM
	(
		SELECT
			group_id, member_id, joined_at
		FROM
			group_members
		WHERE
			member_id = $1
		ORDER BY
			group_id
	) cm
	LEFT JOIN groups g ON cm.group_id = g.group_id
LIMIT
	$2
OFFSET
	$3
`

type GetAllUserGroupsParams struct {
	MemberID pgtype.UUID `json:"member_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type GetAllUserGroupsRow struct {
	GroupID      pgtype.UUID      `json:"group_id"`
	GroupName    pgtype.Text      `json:"group_name"`
	GroupPicture pgtype.Text      `json:"group_picture"`
	CreatedBy    pgtype.UUID      `json:"created_by"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	JoinedAt     pgtype.Timestamp `json:"joined_at"`
}

func (q *Queries) GetAllUserGroups(ctx context.Context, arg GetAllUserGroupsParams) ([]GetAllUserGroupsRow, error) {
	rows, err := q.db.Query(ctx, getAllUserGroups, arg.MemberID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllUserGroupsRow{}
	for rows.Next() {
		var i GetAllUserGroupsRow
		if err := rows.Scan(
			&i.GroupID,
			&i.GroupName,
			&i.GroupPicture,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupMemberInfoByName = `-- name: GetGroupMemberInfoByName :many
SELECT
	u.user_id,
	u.user_name,
	u.profile_image,
	g.joined_at
FROM
	(
		SELECT
			group_id, member_id, joined_at
		FROM
			group_members
		WHERE
			group_id = $1
	) g
	LEFT JOIN users u ON g.member_id = u.user_id
WHERE
	u.user_name LIKE ('%' || $2 || '%')
ORDER BY
	g.joined_at
LIMIT
	$3
OFFSET
	$4
`

type GetGroupMemberInfoByNameParams struct {
	GroupID pgtype.UUID `json:"group_id"`
	Column2 pgtype.Text `json:"column_2"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type GetGroupMemberInfoByNameRow struct {
	UserID       pgtype.UUID      `json:"user_id"`
	UserName     pgtype.Text      `json:"user_name"`
	ProfileImage pgtype.Text      `json:"profile_image"`
	JoinedAt     pgtype.Timestamp `json:"joined_at"`
}

func (q *Queries) GetGroupMemberInfoByName(ctx context.Context, arg GetGroupMemberInfoByNameParams) ([]GetGroupMemberInfoByNameRow, error) {
	rows, err := q.db.Query(ctx, getGroupMemberInfoByName,
		arg.GroupID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGroupMemberInfoByNameRow{}
	for rows.Next() {
		var i GetGroupMemberInfoByNameRow
		if err := rows.Scan(
			&i.UserID,
			&i.UserName,
			&i.ProfileImage,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupMembersTable = `-- name: GetGroupMembersTable :many
SELECT
	group_id, member_id, joined_at
FROM
	group_members
`

func (q *Queries) GetGroupMembersTable(ctx context.Context) ([]GroupMember, error) {
	rows, err := q.db.Query(ctx, getGroupMembersTable)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GroupMember{}
	for rows.Next() {
		var i GroupMember
		if err := rows.Scan(&i.GroupID, &i.MemberID, &i.JoinedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

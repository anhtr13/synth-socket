// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: room_queries.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRoom = `-- name: CreateRoom :one
INSERT INTO
	rooms (room_name, room_picture, created_by)
VALUES
	($1, $2, $3)
RETURNING
	room_id, room_name, room_picture, created_by, updated_at, created_at, last_message
`

type CreateRoomParams struct {
	RoomName    string      `json:"room_name"`
	RoomPicture pgtype.Text `json:"room_picture"`
	CreatedBy   pgtype.UUID `json:"created_by"`
}

func (q *Queries) CreateRoom(ctx context.Context, arg CreateRoomParams) (Room, error) {
	row := q.db.QueryRow(ctx, createRoom, arg.RoomName, arg.RoomPicture, arg.CreatedBy)
	var i Room
	err := row.Scan(
		&i.RoomID,
		&i.RoomName,
		&i.RoomPicture,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.LastMessage,
	)
	return i, err
}

const findRoomByCreatorAndName = `-- name: FindRoomByCreatorAndName :one
SELECT
	room_id, room_name, room_picture, created_by, updated_at, created_at, last_message
FROM
	rooms
WHERE
	created_by = $1
	AND room_name = $2
`

type FindRoomByCreatorAndNameParams struct {
	CreatedBy pgtype.UUID `json:"created_by"`
	RoomName  string      `json:"room_name"`
}

func (q *Queries) FindRoomByCreatorAndName(ctx context.Context, arg FindRoomByCreatorAndNameParams) (Room, error) {
	row := q.db.QueryRow(ctx, findRoomByCreatorAndName, arg.CreatedBy, arg.RoomName)
	var i Room
	err := row.Scan(
		&i.RoomID,
		&i.RoomName,
		&i.RoomPicture,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.LastMessage,
	)
	return i, err
}

const findRoomById = `-- name: FindRoomById :one
SELECT
	room_id, room_name, room_picture, created_by, updated_at, created_at, last_message
FROM
	rooms
WHERE
	room_id = $1
`

func (q *Queries) FindRoomById(ctx context.Context, roomID pgtype.UUID) (Room, error) {
	row := q.db.QueryRow(ctx, findRoomById, roomID)
	var i Room
	err := row.Scan(
		&i.RoomID,
		&i.RoomName,
		&i.RoomPicture,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.LastMessage,
	)
	return i, err
}

const getRoomsByCreator = `-- name: GetRoomsByCreator :many
SELECT
	room_id, room_name, room_picture, created_by, updated_at, created_at, last_message
FROM
	rooms
WHERE
	created_by = $1
ORDER BY
	room_name
LIMIT
	$2
OFFSET
	$3
`

type GetRoomsByCreatorParams struct {
	CreatedBy pgtype.UUID `json:"created_by"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) GetRoomsByCreator(ctx context.Context, arg GetRoomsByCreatorParams) ([]Room, error) {
	rows, err := q.db.Query(ctx, getRoomsByCreator, arg.CreatedBy, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Room{}
	for rows.Next() {
		var i Room
		if err := rows.Scan(
			&i.RoomID,
			&i.RoomName,
			&i.RoomPicture,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.LastMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomsByCreatorAndName = `-- name: GetRoomsByCreatorAndName :many
SELECT
	room_id, room_name, room_picture, created_by, updated_at, created_at, last_message
FROM
	rooms
WHERE
	created_by = $1
	AND room_name LIKE ('%' || $4 || '%')
ORDER BY
	room_name
LIMIT
	$2
OFFSET
	$3
`

type GetRoomsByCreatorAndNameParams struct {
	CreatedBy pgtype.UUID `json:"created_by"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	RoomName  pgtype.Text `json:"room_name"`
}

func (q *Queries) GetRoomsByCreatorAndName(ctx context.Context, arg GetRoomsByCreatorAndNameParams) ([]Room, error) {
	rows, err := q.db.Query(ctx, getRoomsByCreatorAndName,
		arg.CreatedBy,
		arg.Limit,
		arg.Offset,
		arg.RoomName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Room{}
	for rows.Next() {
		var i Room
		if err := rows.Scan(
			&i.RoomID,
			&i.RoomName,
			&i.RoomPicture,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.LastMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomsDataByMemberId = `-- name: GetRoomsDataByMemberId :many
SELECT
	r.room_id, r.room_name, r.room_picture, r.created_by, r.updated_at, r.created_at, r.last_message,
	rm.joined_at
FROM
	(
		SELECT
			room_id, member_id, joined_at
		FROM
			room_members
		WHERE
			member_id = $1
	) rm
	LEFT JOIN rooms r ON rm.room_id = r.room_id
ORDER BY
	r.updated_at DESC
LIMIT
	$2
OFFSET
	$3
`

type GetRoomsDataByMemberIdParams struct {
	MemberID pgtype.UUID `json:"member_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type GetRoomsDataByMemberIdRow struct {
	RoomID      pgtype.UUID      `json:"room_id"`
	RoomName    pgtype.Text      `json:"room_name"`
	RoomPicture pgtype.Text      `json:"room_picture"`
	CreatedBy   pgtype.UUID      `json:"created_by"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	LastMessage pgtype.UUID      `json:"last_message"`
	JoinedAt    pgtype.Timestamp `json:"joined_at"`
}

func (q *Queries) GetRoomsDataByMemberId(ctx context.Context, arg GetRoomsDataByMemberIdParams) ([]GetRoomsDataByMemberIdRow, error) {
	rows, err := q.db.Query(ctx, getRoomsDataByMemberId, arg.MemberID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRoomsDataByMemberIdRow{}
	for rows.Next() {
		var i GetRoomsDataByMemberIdRow
		if err := rows.Scan(
			&i.RoomID,
			&i.RoomName,
			&i.RoomPicture,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.LastMessage,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomsDataByMemberIdAndRoomName = `-- name: GetRoomsDataByMemberIdAndRoomName :many
SELECT
	r.room_id, r.room_name, r.room_picture, r.created_by, r.updated_at, r.created_at, r.last_message,
	rm.joined_at
FROM
	(
		SELECT
			room_id, member_id, joined_at
		FROM
			room_members
		WHERE
			member_id = $1
	) rm
	LEFT JOIN rooms r ON rm.room_id = r.room_id
WHERE
	r.room_name LIKE ('%' || $4 || '%')
ORDER BY
	r.room_name
LIMIT
	$2
OFFSET
	$3
`

type GetRoomsDataByMemberIdAndRoomNameParams struct {
	MemberID pgtype.UUID `json:"member_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	Name     pgtype.Text `json:"name"`
}

type GetRoomsDataByMemberIdAndRoomNameRow struct {
	RoomID      pgtype.UUID      `json:"room_id"`
	RoomName    pgtype.Text      `json:"room_name"`
	RoomPicture pgtype.Text      `json:"room_picture"`
	CreatedBy   pgtype.UUID      `json:"created_by"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	LastMessage pgtype.UUID      `json:"last_message"`
	JoinedAt    pgtype.Timestamp `json:"joined_at"`
}

func (q *Queries) GetRoomsDataByMemberIdAndRoomName(ctx context.Context, arg GetRoomsDataByMemberIdAndRoomNameParams) ([]GetRoomsDataByMemberIdAndRoomNameRow, error) {
	rows, err := q.db.Query(ctx, getRoomsDataByMemberIdAndRoomName,
		arg.MemberID,
		arg.Limit,
		arg.Offset,
		arg.Name,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRoomsDataByMemberIdAndRoomNameRow{}
	for rows.Next() {
		var i GetRoomsDataByMemberIdAndRoomNameRow
		if err := rows.Scan(
			&i.RoomID,
			&i.RoomName,
			&i.RoomPicture,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.LastMessage,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRoomLastMessage = `-- name: UpdateRoomLastMessage :exec
UPDATE rooms
SET
	last_message = $1,
	updated_at = $2
WHERE
	room_id = $3
`

type UpdateRoomLastMessageParams struct {
	LastMessage pgtype.UUID      `json:"last_message"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	RoomID      pgtype.UUID      `json:"room_id"`
}

func (q *Queries) UpdateRoomLastMessage(ctx context.Context, arg UpdateRoomLastMessageParams) error {
	_, err := q.db.Exec(ctx, updateRoomLastMessage, arg.LastMessage, arg.UpdatedAt, arg.RoomID)
	return err
}
